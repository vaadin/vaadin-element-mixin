<script>
(function() {
  /**
   * Array of Vaadin custom element classes that have been subscribed to the dir changes.
   */
  const directionSubscribers = [];
  const directionUpdater = function() {
    if (directionSubscribers) {
      directionSubscribers.forEach(element => {
        if (document.documentElement.getAttribute('dir')) {
          element.setAttribute('dir', document.documentElement.getAttribute('dir'));
        } else {
          element.removeAttribute('dir');
        }
      });
    }
  };

  const directionObserver = new MutationObserver(directionUpdater);
  directionObserver.observe(document.documentElement, {attributes: true, attributeFilter: ['dir']});

  /**
   * @polymerMixin
   * @memberof Vaadin
   */
  Vaadin.DirMixin = superClass => class VaadinDirMixin extends superClass {
    static get properties() {
      return {
        /**
         * @protected
         */
        dir: {
          type: String,
          readOnly: true
        }
      };
    }
    connectedCallback() {
      super.connectedCallback();

      if (!this.hasAttribute('dir')) {
        this.__subscribe();
        this.__alignDirs();
      }
    }

    /** @protected */
    attributeChangedCallback(name, oldValue, newValue) {
      super.attributeChangedCallback(name, oldValue, newValue);
      if (name !== 'dir') {
        return;
      }

      // New value equals to the document direction and the element is not subscribed to the changes
      const newValueEqlDocDir = newValue === this.__getDocumentDir() && directionSubscribers.indexOf(this) === -1;
      // Value was emptied and the element is not subscribed to the changes
      const newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1;
      // New value is different and the old equals to document direction and the element is not subscribed to the changes
      const newDiffValue = newValue !== this.__getDocumentDir() && oldValue === this.__getDocumentDir();

      if (newValueEqlDocDir || newValueEmptied) {
        this.__subscribe();
        this.__alignDirs();
      } else if (newDiffValue) {
        this.__subscribe(false);
      }
    }

    __alignDirs() {
      if (this.__getDocumentDir()) {
        this.setAttribute('dir', this.__getDocumentDir());
      } else {
        this.removeAttribute('dir');
      }
    }

    __getDocumentDir() {
      return document.documentElement.getAttribute('dir');
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      this.__subscribe(false);
    }

    __subscribe(push = true) {
      if (push) {
        directionSubscribers.indexOf(this) === -1 &&
          directionSubscribers.push(this);
      } else {
        directionSubscribers.indexOf(this) > -1 &&
          directionSubscribers.splice(directionSubscribers.indexOf(this), 1);
      }
    }
  };
})();
</script>
